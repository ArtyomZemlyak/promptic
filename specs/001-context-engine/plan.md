# Implementation Plan: Context Engineering Library

**Branch**: `001-context-engine` | **Date**: 2025-11-17 | **Spec**: [spec.md](./spec.md)  
**Input**: Feature specification from `/specs/001-context-engine/spec.md`

**Note**: This plan assumes we are building a Python library with iterative releases but designs for the “final” extensible architecture so later iterations reuse the same modules.

## Summary

We will ship a Python 3.11+ library that lets designers compose full conversational contexts (prompt + reusable instructions + data slots + memory slots) as hierarchical blueprints, plug any data/memory providers through adapters, and execute pipelines where each step can recurse through its own instruction assets. A dedicated `ContextMaterializer` use case will broker adapter registry lookups, caching, and error handling for both preview and execution flows so `ContextPreviewer` and `PipelineExecutor` stay focused on traversal logic. The technical plan commits to clean layering (domain blueprints, use-case services, adapters), Pydantic-based schemas/settings, and deterministic tooling so we can iterate rapidly without rewriting architecture.

**Scope guardrail**: This release intentionally excludes HTTP/REST endpoints, CLI utilities, or persistent services. All consumer touchpoints are the Python SDK.

## Technical Context

**Language/Version**: Python 3.11 (CPython)  
**Primary Dependencies**: `pydantic>=2`, `pydantic-settings`, `rich` (logging/preview), `jinja2` (templating), `orjson`, optional adapter extras (e.g., `httpx`, `sqlalchemy`, `faiss-cpu`)  
**Storage**: Default local filesystem for instruction assets + adapter interfaces for external stores (HTTP APIs, vector DBs, Redis). No persistent DB baked into core.  
**Testing**: `pytest`, `pytest-asyncio` for async adapters, `hypothesis` for blueprint validation fuzzing, golden-file tests for context rendering.  
**Target Platform**: Linux (WSL2) + macOS + GitHub Actions CI; library remains platform-agnostic.  
**Project Type**: Single Python package (`src/promptic/`) with SDK-facing modules and supporting docs.  
**Performance Goals**: Render 5-step hierarchical blueprint with ≤100 instruction nodes in <500 ms on developer hardware; adapter registry loads within 200 ms; blueprint validation handles 1k nodes under 2 s.  
**Constraints**: Keep in-memory context payloads <256 MB by enforcing per-step size budgets; zero external network calls in core (adapters isolate them); all configuration via Pydantic settings objects.  
**Scale/Scope**: Support dozens of concurrent blueprints per process, each with nested pipelines, initial release focusing on authoring/execution flows plus extensibility hooks for future multi-agent orchestration.

## Constitution Check

- **Architecture**: Domain layer holds `ContextBlueprint`, `InstructionNode`, slots, and value objects. Use cases (`BlueprintBuilder`, `ContextMaterializer`, `ContextPreviewer`, `PipelineExecutor`) depend only on interfaces (`InstructionStore`, `DataSourceAdapter`, `MemoryProvider`). `ContextMaterializer` centralizes registry access/caching so preview/execution flows do not reach directly into adapter layers. Interface adapters live under `adapters/` for filesystem, HTTP, vector DB, etc. No framework imports leak inward. Status: PASS.
- **Testing Evidence**: Commit to unit suites for schema validation, adapter registries, executor traversal; integration suites for 5-step sample pipeline across two adapter implementations; contract suites ensuring adapters honor required async/sync signatures. All tests run via `pytest -m "unit or integration or contract"` with CI enforcement. Status: PASS.
- **Quality Gates**: Black (line length 100), isort (profile black), mypy (strict optional), plus `pre-commit run --all-files` before each commit. Lint results captured in PR template. Status: PASS.
- **Documentation & Traceability**: Update `docs_site/context-engineering/` with blueprint schema, adapter integration, execution walkthrough; ensure spec/plan/data-model/contracts stay in sync; capture architectural rationale in `# AICODE-NOTE` comments and research.md. Status: PASS.
- **Readability & DX**: Enforce modules <400 lines, functions <100 logical lines, and descriptive names (`render_context_preview`). Provide SDK convenience functions + quickstart so designers avoid touching low-level modules. Status: PASS.
- **AICODE-NOTE**: Readability limits are treated as reviewer guidelines; we rely on Black (line length 100), isort, and PR review rather than building bespoke linters for counting lines.

Re-check Constitution gates after Phase 1 artifacts are generated; any deviation requires entries in “Complexity Tracking.”

## Project Structure

### Documentation (this feature)

```text
specs/001-context-engine/
├── plan.md
├── research.md
├── data-model.md
├── quickstart.md
├── contracts/
│   └── context-engineering.yaml
└── tasks.md              # Generated by /speckit.tasks (future)
```

### Source Code (repository root)

```text
src/
└── promptic/
    ├── blueprints/            # Domain models + serialization
    ├── instructions/          # Instruction stores + caching
    ├── pipeline/              # Use cases: builder, materializer, previewer, executor
    ├── adapters/
    │   ├── data/
    │   └── memory/
    ├── context/               # Rendering + logging utilities
    ├── settings/              # Pydantic settings profiles
    └── sdk/                   # High-level SDK façades

tests/
├── unit/
├── integration/
└── contract/

docs_site/
└── context-engineering/
    ├── blueprint-guide.md
    ├── adapter-guide.md
    └── execution-recipes.md
```

**Structure Decision**: Ship as a single Python package with modular subpackages so adapters, pipeline logic, and SDK façades can evolve independently. Tests mirror source tree (unit vs integration vs contract). Documentation lives under `docs_site/context-engineering/` so guides stay co-located with specs. This layout keeps clean architecture layers explicit and simplifies packaging to PyPI later.

## Complexity Tracking

No Constitution violations are anticipated; table intentionally left empty. Populate only if future iterations justify exceptions (e.g., extra runtime service or skipped tests).
