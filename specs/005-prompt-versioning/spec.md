# Feature Specification: Prompt Versioning System

**Feature Branch**: `005-prompt-versioning`  
**Created**: 2025-01-28  
**Status**: Draft  
**Input**: User description: "добавляем версионность - добавляем версионность - отдельная функция очищения экспортированной версии В версионности нужно учитывать: - мы работаем с файлами и не завязываем версионность на git - подход dvc мне тоже не нравится, так как он в итоге все равно все завязывает на git - версионность должна предоставляться нашей библиотекой - версионность должна работать как и для inline так и для file first режимов для file first: - добавляем функцию экспорта конкретной версии прям по пути в файловой системе - плюс возврат корневого промпта, чтобы с него начать Само версионирование хочется видеть примерно так: - папка промптов для какой-то задачи -- корневой промпт v1 -- корневой промпт v2 -- папка внутреннего промпта --- внутренний промпт v1 --- внутренний промпт v2 Чтобы получить конкретную версию всего промпта есть следующие варианты: - указываем папку и указываем version=\"latest\", это по умолчанию поведение и тогда смотрится конкретная папка и последняя версия в ней - указываем папку и указываем version=\"v1\", тогда берется версия с конкретным postfix (который в целом может быть любым) - указываем конкретный файл промпта Чтобы вставить внутренний промпт в другой файл промпта с определенной версией: - указываем папку и тогда от туда берется промпт последней версии - указываем конкретный файл промпта При создании фичи учитывай что у нас уже была 004"
> This specification MUST satisfy the `promptic Constitution`: clean architecture layering, SOLID responsibilities, mandatory tests, documentation updates, and readability.

**Scope Clarification**: This feature introduces a filesystem-based versioning system for prompts that operates independently of git or external version control systems. The library provides version management capabilities for both inline and file-first modes. The system supports hierarchical versioning structures where root prompts and nested prompts can each have multiple versions. Versioning is handled entirely by the library through file naming conventions (version postfixes like `v1`, `v2`) and directory scanning. Users can reference prompts by folder (defaulting to latest version) or by specific versioned files. For file-first mode, the system provides functionality to export specific versions directly to the filesystem and retrieve the root prompt for that version.

**Value Proposition**: Prompt designers need to maintain multiple versions of prompts for iteration, testing, and rollback purposes. Without built-in versioning, designers resort to manual file copying, git branching, or external tools that couple version management with version control workflows. This feature provides a library-native versioning solution that works seamlessly with both inline and file-first modes, allowing designers to organize prompt versions hierarchically, reference specific versions programmatically, and export complete version snapshots without depending on git or external tools.

**Problems Solved**: The versioning system addresses several practical problems: (1) designers currently have no standard way to manage prompt versions, leading to ad-hoc solutions like manual file copies or git branches that mix version control with prompt versioning, (2) referencing specific prompt versions requires manual path management, (3) exporting complete prompt hierarchies for a specific version requires manual file collection, (4) inline and file-first modes lack consistent versioning support. This feature provides a unified, filesystem-based versioning solution that integrates with existing prompt loading and rendering workflows.

**Real-World Use Cases**: Production systems managing complex prompt hierarchies (like tg-note) face challenges when iterating on prompts: designers need to test multiple versions, compare performance, and rollback to previous versions without disrupting active workflows. The versioning system enables designers to maintain version histories directly in the filesystem, reference specific versions in code, export complete snapshots for deployment or testing, and organize versions hierarchically to match prompt structure.

## Clarifications

### Session 2025-01-28

- Q: How should export structure be organized - flattened or preserving hierarchical structure? → A: Export MUST preserve the hierarchical directory structure of the source prompts, not flatten. The export maintains the same directory layout as the source, with nested prompts in their respective subdirectories. Path references in internal prompts are resolved to maintain relative path relationships within the exported structure.
- Q: What version notation format should be used? → A: The system uses semantic versioning notation (v0.0.0) as the standard format, with support for simplified forms: `v1` (equivalent to v1.0.0), `v1.1` (equivalent to v1.1.0), and `v1.1.1` (full semantic version). Version comparison follows semantic versioning rules where major.minor.patch components are compared numerically. Simplified forms are normalized during comparison (v1 → v1.0.0, v1.1 → v1.1.0).
- Q: How should conflicts between versioned and unversioned files be handled? → A: Versioned files have priority over unversioned files. If a directory contains both `prompt.md` and `prompt_v1.md`, when loading the directory the system ignores the unversioned file and uses versioned files only. The unversioned file `prompt.md` is used only if no versioned files exist for that prompt base name. This ensures predictable behavior: when versions exist, versioning is enforced; unversioned files serve as fallback when no versions are present.
- Q: What should happen when a referenced file is missing during export? → A: Export MUST stop with an error `ExportError` listing all missing files. Export must be atomic—either all files export successfully or nothing is exported. Partial exports are not allowed as they would create incomplete hierarchies with broken references, which is critical for file-first mode where references must be valid.
- Q: What should happen when a directory contains no versioned files? → A: If a directory contains no versioned files, the system checks for an unversioned file with the base prompt name (e.g., `prompt.md`). If such a file exists, it is used as the default version. If no files exist at all for the prompt base name, the system raises `VersionNotFoundError`. This ensures backward compatibility: if users haven't started versioning yet, the system continues working with unversioned files. Empty directories or missing files indicate a configuration error.
- Q: How should concurrent access and file locking be handled during export? → A: Export operations are idempotent without file locking. If the target directory already exists, the system raises `ExportDirectoryExistsError` (unless `overwrite=True` is specified). Parallel exports to different directories are allowed without restrictions. Parallel exports to the same directory indicate a configuration error requiring explicit action. This avoids unnecessary locking complexity while ensuring deterministic behavior: for a given version, export results are always identical. File system locks are not used as they would add complexity without significant benefit for read-mostly export operations.
- Q: What level of logging and diagnostics should be provided for debugging version resolution? → A: The system provides detailed logging with DEBUG/INFO/WARNING/ERROR levels covering all versioning operations: version resolution steps, file discovery, version comparison, caching operations, export progress, and cleanup operations. The logging level is configurable via environment variable (e.g., `PROMPTIC_LOG_LEVEL=DEBUG`) allowing users to control verbosity. Default logging level is INFO. All log entries are structured with fields (version, path, operation) for easy filtering and analysis. High detail logging enables comprehensive diagnostics while configurability prevents log noise in production.

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Version-Aware Prompt Loading (Priority: P1)

Prompt designers can load prompts from a folder, automatically resolving to the latest version or specifying an exact version identifier. The system scans directories for versioned files (e.g., `prompt_v1.md`, `prompt_v2.md`) and selects the appropriate version based on user input.

**Why this priority**: This is the foundational capability that enables all versioning features. Without version-aware loading, designers cannot reference specific prompt versions or default to latest versions. This is the core user journey for version management.

**Independent Test**: A designer creates a folder `prompts/task1/` containing three files: `root_prompt_v1.md`, `root_prompt_v2.md`, and `root_prompt_v3.md`. Loading `prompts/task1/` with `version="latest"` (or default) loads `root_prompt_v3.md`. Loading with `version="v2"` loads `root_prompt_v2.md`. Loading with `version="v1"` loads `root_prompt_v1.md`. All three scenarios complete successfully, proving version resolution works independently.

**Architecture Impact**: Extends `promptic.instructions.store` to support version-aware file discovery. Introduces `VersionResolver` interface in the domain layer that scans directories for versioned files. Updates `NodeNetworkBuilder` to pass version parameters through the loading pipeline. Introduces `VersionedFileScanner` in adapter layer that implements filesystem scanning using version postfix detection. Enforces SRP by separating version detection, version resolution, and file loading into distinct services. Uses DIP so version resolution depends on `VersionResolver` interface rather than concrete scanning implementation.

**Quality Signals**: Unit tests for version detection logic (extracting versions from filenames), unit tests for version comparison (determining latest version), integration tests loading prompts with different version specifications, contract tests for `VersionResolver` interface, docs_site guide "Prompt versioning", `AICODE-NOTE` explaining version resolution strategy.

**Acceptance Scenarios**:

1. **Given** a folder containing `root_prompt_v1.md`, `root_prompt_v2.md`, and `root_prompt_v3.md`, **When** loading the folder with `version="latest"` (or default), **Then** the system loads `root_prompt_v3.md`.
2. **Given** a folder containing versioned prompt files, **When** loading with `version="v2"`, **Then** the system loads the file with `_v2` postfix (or equivalent version identifier).
3. **Given** a specific prompt file path (e.g., `prompts/task1/root_prompt_v2.md`), **When** loading the file directly, **Then** the system loads the exact file without version resolution.
4. **Given** a folder containing a single unversioned file `root_prompt.md` (no versioned files exist), **When** loading the folder, **Then** the system loads the unversioned file, treating it as the default/latest version.
5. **Given** a folder with no files matching the prompt base name, **When** loading the folder, **Then** the system raises `VersionNotFoundError` indicating that no prompt files were found.
6. **Given** a folder with no matching version (e.g., requesting `version="v5"` but only `v1`, `v2`, `v3` exist), **When** loading with that version specification, **Then** the system raises `VersionNotFoundError` with details about available versions.

---

### User Story 2 - Hierarchical Version Resolution (Priority: P2)

Prompt designers can organize prompts in hierarchical structures where root prompts and nested prompts each have their own version histories. When loading a root prompt at a specific version, nested prompts resolve to their latest versions unless explicitly specified.

**Why this priority**: Real-world prompt hierarchies include nested prompts (e.g., root blueprint references instruction files, which may reference data templates). Designers need version management that respects this hierarchy—root prompts can be versioned independently of nested prompts. However, this can be built incrementally after basic version loading works.

**Independent Test**: A designer creates a structure: `prompts/task1/root_prompt_v1.md` (references `instructions/process.md`), `prompts/task1/root_prompt_v2.md` (references `instructions/process.md`), `prompts/task1/instructions/process_v1.md`, and `prompts/task1/instructions/process_v2.md`. Loading `prompts/task1/` with `version="v1"` loads `root_prompt_v1.md`, which references `instructions/process.md` (resolved to `instructions/process_v2.md` as latest). Loading with explicit nested version `version={"root": "v1", "instructions/process": "v1"}` loads `root_prompt_v1.md` with `instructions/process_v1.md`. This proves hierarchical version resolution works independently.

**Architecture Impact**: Extends `VersionResolver` to support hierarchical version specifications (dictionary mapping path patterns to versions). Updates `NodeNetworkBuilder` to apply version resolution recursively when resolving nested references. Introduces `HierarchicalVersionResolver` that applies version rules at each directory level. Maintains SRP by keeping hierarchical resolution logic separate from single-file version resolution. Uses DIP so network building depends on version resolver interfaces rather than concrete implementations.

**Quality Signals**: Unit tests for hierarchical version specification parsing, integration tests loading nested prompts with version combinations, contract tests for hierarchical version resolution, docs_site guide "Hierarchical prompt versioning", `AICODE-NOTE` explaining hierarchical resolution strategy.

**Acceptance Scenarios**:

1. **Given** a root prompt at version `v1` that references nested prompt `instructions/process.md`, **When** loading the root prompt, **Then** the nested prompt resolves to its latest version (`instructions/process_v2.md`) by default.
2. **Given** a hierarchical version specification mapping root to `v1` and nested path to `v1`, **When** loading the prompt hierarchy, **Then** both root and nested prompts load at their specified versions.
3. **Given** a nested prompt folder with versioned files, **When** a parent prompt references the folder without a version, **Then** the system resolves to the latest version in that folder.
4. **Given** a nested prompt reference that includes a specific file path (e.g., `instructions/process_v1.md`), **When** loading the parent prompt, **Then** the system uses the exact file without version resolution.

---

### User Story 3 - Version Export for File-First Mode (Priority: P3)

Prompt designers can export a complete version snapshot of a prompt hierarchy to a target directory in the filesystem. The export preserves the hierarchical directory structure of the source prompts (not flattened), maintaining nested subdirectories and resolving path references in internal prompts to work correctly within the exported structure. The export returns the root prompt content for immediate use.

**Why this priority**: Designers need to create deployable snapshots of specific prompt versions for testing, deployment, or sharing. File-first mode benefits from this because it enables exporting compact root prompts plus all referenced files as a complete package with preserved structure. However, this can be built after version loading and hierarchical resolution are working.

**Independent Test**: A designer has a prompt hierarchy: `prompts/task1/root_prompt_v2.md` (references `instructions/process.md` and `templates/data.md`), with `prompts/task1/instructions/process_v2.md` and `prompts/task1/templates/data_v2.md`. Exporting `prompts/task1/` with `version="latest"` to `export/task1_v2/` creates: `export/task1_v2/root_prompt.md` (copied from `root_prompt_v2.md` with path references resolved), `export/task1_v2/instructions/process.md` (copied from `instructions/process_v2.md`), and `export/task1_v2/templates/data.md` (copied from `templates/data_v2.md`). The hierarchical structure is preserved (instructions and templates remain in subdirectories), and path references in the root prompt are resolved to work correctly in the exported structure. The function returns the root prompt content for immediate rendering. This proves export works independently while preserving structure.

**Architecture Impact**: Introduces `VersionExporter` use case in domain layer that orchestrates version resolution, file discovery, and filesystem operations. Creates `FileSystemExporter` adapter that handles directory creation, file copying, and path resolution. Extends `NodeNetworkBuilder` to support export mode that collects all referenced files. Maintains SRP by separating export orchestration (use case) from filesystem operations (adapter). Uses DIP so exporter depends on version resolver and file store interfaces rather than concrete implementations.

**Quality Signals**: Unit tests for export orchestration logic, integration tests exporting complex hierarchies with multiple nested levels, contract tests for export interfaces, docs_site guide "Exporting prompt versions", `AICODE-NOTE` explaining export structure and file organization.

**Acceptance Scenarios**:

1. **Given** a prompt hierarchy with root and nested prompts, **When** exporting a specific version to a target directory, **Then** the system preserves the hierarchical directory structure (nested prompts remain in their subdirectories) with all referenced prompts at their resolved versions.
2. **Given** a prompt hierarchy where root prompt contains path references to nested prompts, **When** exporting a version, **Then** the system resolves path references in the exported root prompt to work correctly with the preserved directory structure (e.g., `instructions/process.md` remains valid in the exported structure).
3. **Given** a version export operation, **When** the export completes, **Then** the function returns the root prompt content (with resolved paths) for immediate use in rendering.
4. **Given** a target export directory that already exists, **When** exporting a version, **Then** the system raises `ExportDirectoryExistsError` unless `overwrite=True` is specified.
5. **Given** an export operation that encounters missing referenced files, **When** exporting, **Then** the system raises `ExportError` with details about missing files.

---

### User Story 4 - Version Cleanup Function (Priority: P3)

Prompt designers can clean up exported version snapshots by removing exported directories. The cleanup function validates that target directories are export directories (not source prompt directories) to prevent accidental deletion of source prompts.

**Why this priority**: Designers need to manage exported snapshots to avoid filesystem clutter. However, this is a utility function that can be built after export functionality is working. It's important for workflow completeness but not critical for initial versioning functionality.

**Independent Test**: A designer exports a version to `export/task1_v2/` and then calls the cleanup function with that path. The directory and all contents are removed. Calling cleanup with a source prompt directory (e.g., `prompts/task1/`) raises `InvalidCleanupTargetError`. Calling cleanup with a non-existent path raises `CleanupTargetNotFoundError`. This proves cleanup works independently with proper safeguards.

**Architecture Impact**: Introduces `VersionCleanup` use case that validates cleanup targets and orchestrates directory removal. Creates `FileSystemCleanup` adapter that performs safe directory deletion with validation. Maintains SRP by separating validation logic from filesystem operations. Uses DIP so cleanup depends on filesystem interfaces rather than concrete implementations.

**Quality Signals**: Unit tests for cleanup validation logic, integration tests cleaning up exported directories, safety tests preventing deletion of source directories, docs_site guide "Managing exported versions", `AICODE-NOTE` explaining cleanup safeguards.

**Acceptance Scenarios**:

1. **Given** an exported version directory, **When** calling cleanup with that path, **Then** the directory and all contents are removed.
2. **Given** a source prompt directory path, **When** calling cleanup with that path, **Then** the system raises `InvalidCleanupTargetError` preventing accidental deletion of source prompts.
3. **Given** a non-existent export directory path, **When** calling cleanup, **Then** the system raises `CleanupTargetNotFoundError`.
4. **Given** an export directory containing subdirectories, **When** calling cleanup, **Then** all nested files and directories are removed recursively.

---

### Edge Cases

- **Version postfix detection ambiguity**: When a file has multiple version-like patterns (e.g., `prompt_v1.0_final_v2.1.md`), the system uses a deterministic rule: extract the last semantic version pattern (`_v{N}`, `_v{N}.{N}`, or `_v{N}.{N}.{N}`) as the version identifier. If ambiguity persists, raise `VersionDetectionError` with file suggestions.
- **Missing version files**: When a requested version doesn't exist (e.g., requesting `v5` but only `v1-v3` exist), the system raises `VersionNotFoundError` listing available versions and suggesting alternatives (e.g., "Version v5 not found. Available versions: v1, v2, v3. Did you mean v3 (latest)?")
- **Circular version references**: When nested prompts reference each other at specific versions that create circular dependencies, the system detects cycles during version resolution and raises `VersionResolutionCycleError` with the cycle path.
- **Mixed versioned and unversioned files**: When a directory contains both versioned files (`prompt_v1.md`, `prompt_v2.md`) and an unversioned file (`prompt.md`), the system ignores the unversioned file and uses versioned files only. The unversioned file is used only if no versioned files exist for that prompt base name. When versioned files are present, versioning is enforced and unversioned files with the same base name are ignored. This ensures predictable behavior and prevents ambiguity between versioned and unversioned naming schemes.
- **Empty directories or missing files**: When a directory contains no files matching the prompt base name (neither versioned nor unversioned), the system raises `VersionNotFoundError` indicating that no prompt files were found. If an unversioned file exists but no versioned files exist, the unversioned file is used as the default version to ensure backward compatibility with non-versioned workflows.
- **Export directory conflicts**: When exporting to a directory that contains existing files (not from a previous export), the system raises `ExportDirectoryConflictError` unless `overwrite=True` is specified. The function validates directory contents to distinguish between safe overwrites (previous exports) and dangerous overwrites (user files).
- **Version resolution performance**: When scanning directories with hundreds of versioned files, the system should cache version listings to avoid repeated filesystem scans. Cache invalidation occurs when directory modification time changes.
- **Relative vs absolute paths in exports**: When exporting nested prompts that reference other prompts using relative paths, the system preserves relative path relationships in the export structure, ensuring exported hierarchies remain functional.
- **Inline mode version support**: When using inline mode (not file-first), versioning applies to the blueprint/instruction source files that are loaded before inlining. The inlined output doesn't preserve version information, but the source file selection respects version specifications.
- **Cleanup validation false positives**: The cleanup validation must distinguish between export directories (created by the export function) and source directories (user-managed prompt folders). The system uses heuristics: export directories typically have version postfixes in their names, contain preserved hierarchical structures matching source layouts, or have metadata files. If validation is uncertain, require explicit confirmation.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: The system MUST support loading prompts from a directory, automatically resolving to the latest version when `version="latest"` is specified (or omitted, as this is the default behavior).
- **FR-002**: The system MUST support loading prompts with explicit version specifications (e.g., `version="v1"`) that resolve to files with matching version postfixes (e.g., `prompt_v1.md`, `prompt-v1.md`).
- **FR-003**: The system MUST support loading prompts by specific file paths, bypassing version resolution when an exact file path is provided.
- **FR-004**: The system MUST detect version postfixes in filenames using semantic versioning notation (v0.0.0) as the standard format, with support for simplified forms: `_v1` (normalized to v1.0.0), `_v1.1` (normalized to v1.1.0), and `_v1.1.1` (full semantic version). Version identifiers are extracted from filenames using patterns like `_v{N}`, `_v{N}.{N}`, or `_v{N}.{N}.{N}` (e.g., `_v1`, `_v1.1`, `_v1.1.1`).
- **FR-005**: The system MUST determine the "latest" version by comparing version identifiers using semantic versioning rules: versions are compared component-wise (major.minor.patch) numerically, where simplified forms (v1, v1.1) are normalized to full semantic versions (v1.0.0, v1.1.0) during comparison. Comparison follows standard semantic versioning precedence: major version takes precedence over minor, minor over patch.
- **FR-006**: The system MUST support hierarchical version specifications where different parts of a prompt hierarchy can be loaded at different versions (e.g., `version={"root": "v1", "instructions/process": "v2"}`).
- **FR-007**: The system MUST resolve nested prompt references to their latest versions by default when a parent prompt is loaded at a specific version, unless explicit version specifications are provided for nested paths.
- **FR-008**: The system MUST work with both inline and file-first render modes, applying version resolution at the source file loading stage before rendering occurs.
- **FR-009**: The system MUST provide an export function for file-first mode that creates a complete snapshot of a prompt hierarchy at a specific version, copying all referenced files to a target directory while preserving the hierarchical directory structure (not flattened). Nested prompts remain in their respective subdirectories matching the source structure.
- **FR-010**: The export function MUST resolve path references in internal prompts during export, ensuring that relative paths in the exported root prompt and nested prompts work correctly with the preserved directory structure. Path references are updated to maintain correct relative relationships within the exported hierarchy.
- **FR-011**: The export function MUST return the root prompt content (with resolved paths) for immediate use in rendering after export completes.
- **FR-011a**: The export function MUST preserve relative path relationships in the exported structure, ensuring nested references remain functional in the exported hierarchy while maintaining the hierarchical directory layout.
- **FR-012**: The system MUST provide a cleanup function that removes exported version directories, with validation to prevent accidental deletion of source prompt directories.
- **FR-013**: The cleanup function MUST validate that target directories are export directories (created by the export function) before allowing deletion, raising `InvalidCleanupTargetError` for source directories.
- **FR-014**: The system MUST raise `VersionNotFoundError` when a requested version doesn't exist, providing details about available versions and suggesting alternatives (e.g., latest version).
- **FR-015**: The system MUST handle directories containing both versioned and unversioned files with the same base name: when versioned files exist, they take priority and unversioned files are ignored. Unversioned files are used only when no versioned files exist for that prompt base name. When versioned files are present, versioning is enforced and the system operates in version-aware mode for that prompt.
- **FR-016**: The system MUST detect and prevent circular version references during hierarchical resolution, raising `VersionResolutionCycleError` with cycle path details when cycles are detected.
- **FR-017**: The system MUST operate independently of git or external version control systems, managing versions entirely through filesystem-based file naming conventions and directory scanning.
- **FR-018**: The system MUST support semantic versioning notation (v0.0.0) as the primary format, with automatic normalization of simplified forms (v1 → v1.0.0, v1.1 → v1.1.0). The system MUST support full semantic versions (v1.1.1) and simplified forms (v1, v1.1) for user convenience while maintaining consistent comparison logic.
- **FR-019**: The export function MUST validate that target directories don't contain conflicting files (non-export files) before exporting, raising `ExportDirectoryConflictError` unless `overwrite=True` is specified.
- **FR-020**: The system MUST cache version listings for directories to avoid repeated filesystem scans when loading multiple prompts from the same directory, invalidating cache when directory modification time changes.
- **FR-021**: The system MUST provide detailed structured logging with DEBUG/INFO/WARNING/ERROR levels covering all versioning operations: version resolution steps, file discovery, version comparison, caching operations, export progress, and cleanup operations. Logging level MUST be configurable via environment variable (e.g., `PROMPTIC_LOG_LEVEL`) with default level INFO. All log entries MUST be structured with fields (version, path, operation, timestamp) for easy filtering and analysis.

### Key Entities *(include if feature involves data)*

- **VersionSpec**: Type alias for version specifications used throughout the versioning system. Defined as `Union[str, Dict[str, str]]` where:
  - `str` can be `"latest"` (default behavior, resolves to most recent version) or a specific version string (e.g., `"v1"`, `"v1.1"`, `"v1.1.1"`)
  - `Dict[str, str]` represents hierarchical version specifications mapping path patterns to version strings (e.g., `{"root": "v1", "instructions/process": "v2"}`)
  Used as parameter type in `VersionResolver.resolve_version()`, `VersionExporter.export_version()`, and SDK API functions.

- **VersionResolver**: Interface in domain layer for version resolution strategies. Implementations scan directories for versioned files, extract version identifiers from filenames, compare versions to determine "latest", and resolve specific version requests. Supports both single-file version resolution and hierarchical version resolution where different paths can have different version specifications. Provides `resolve_version(path, version_spec: VersionSpec)` method that returns the resolved file path for a given path and version specification.
- **VersionedFileScanner**: Adapter implementation in adapter layer that performs filesystem operations for version detection. Scans directories for files matching semantic versioning patterns, extracts version identifiers using regex patterns (supporting `_v{N}`, `_v{N}.{N}`, `_v{N}.{N}.{N}` formats), normalizes simplified forms to full semantic versions (v1 → v1.0.0, v1.1 → v1.1.0), and returns sorted lists of available versions using semantic versioning comparison rules. Implements `VersionResolver` interface and handles actual filesystem I/O, caching results to avoid repeated scans.
- **HierarchicalVersionResolver**: Domain entity that extends `VersionResolver` to support hierarchical version specifications. Takes a dictionary mapping path patterns to version specifications and applies version resolution recursively when resolving nested prompt references. Ensures parent-child version relationships are respected (e.g., root at v1 can reference nested prompt at v2). Used by `NodeNetworkBuilder` when loading prompt hierarchies with version specifications.
- **VersionExporter**: Use case in domain layer that orchestrates version export operations. Takes a source prompt path, version specification, and target export directory. Resolves the prompt hierarchy at the specified version, discovers all referenced files, delegates filesystem operations to `FileSystemExporter` adapter (which preserves hierarchical structure and resolves paths), and returns root prompt content (with resolved paths) after export completes. Maintains separation between export orchestration logic (use case) and filesystem operations (adapter).
- **FileSystemExporter**: Adapter implementation that handles actual filesystem operations for version exports. Creates target directories, preserves the hierarchical directory structure from source (maintaining nested subdirectories), copies files from source to target, resolves and updates path references in prompt files to work correctly with the preserved structure, validates directory contents to prevent conflicts, and handles error cases (missing files, permission errors). Implements export interface defined by `VersionExporter` use case. Ensures exported hierarchies remain functional by preserving both directory structure and path relationships.
- **VersionCleanup**: Use case in domain layer that orchestrates cleanup operations for exported version directories. Validates that target directories are export directories (not source directories), checks for existing files, and delegates deletion to `FileSystemCleanup` adapter. Maintains safety checks to prevent accidental deletion of source prompts.
- **FileSystemCleanup**: Adapter implementation that performs safe directory deletion with validation. Validates directory contents to ensure they're export directories, performs recursive deletion of files and subdirectories, and handles error cases (permission errors, locked files). Implements cleanup interface defined by `VersionCleanup` use case.

### Architecture & Quality Constraints *(from Constitution)*

- **AQ-001**: Keep `VersionResolver` interface and `VersionExporter`/`VersionCleanup` use cases in domain/use-case layers; `VersionedFileScanner`, `FileSystemExporter`, and `FileSystemCleanup` implementations in adapter layer. Use dependency inversion so version resolution and export operations depend on resolver/exporter interfaces rather than concrete filesystem implementations. Entities (prompts, nodes) remain unaware of versioning details; versioning is applied at the loading/rendering boundary.
- **AQ-002**: Apply SRP by separating version detection (extracting versions from filenames), version resolution (selecting appropriate files), version export (orchestrating file copying), and version cleanup (validating and deleting). Each service has a single responsibility. Document intentional coupling (e.g., `VersionExporter` depending on `VersionResolver`) via `AICODE-NOTE`. Use adapter pattern to separate filesystem operations from domain logic.
- **AQ-003**: Provide unit tests for version detection logic (filename parsing, version comparison), version resolution (latest vs specific versions), hierarchical resolution, export orchestration, and cleanup validation. Integration tests loading prompts with various version specifications, exporting hierarchies, and cleaning up exports. Contract tests for `VersionResolver` and export interfaces. All run via `pytest` in CI.
- **AQ-004**: Update docs_site with "Prompt versioning" guide covering version naming conventions, loading specific versions, hierarchical versioning, exporting versions, and cleanup. Update inline docstrings for all versioning entities and use cases. Add `AICODE-NOTE` comments explaining version detection strategy, resolution logic, and export structure. Resolve any `AICODE-ASK` prompts before merge.
- **AQ-005**: Enforce readability by limiting version resolution functions to <100 lines, using descriptive names (e.g., `resolve_version_from_directory`, `extract_version_from_filename`, `export_version_hierarchy`), and avoiding complex nested conditionals in version comparison logic. Version detection should use clear regex patterns with comments explaining matching rules.

### Assumptions

- Version postfixes use semantic versioning notation (v0.0.0) as the standard format, with support for simplified forms (v1 → v1.0.0, v1.1 → v1.1.0, v1.1.1). The system normalizes simplified forms to full semantic versions for consistent comparison. Version detection uses patterns matching semantic versioning: `_v{N}`, `_v{N}.{N}`, or `_v{N}.{N}.{N}`.
- Designers organize prompt versions within the same directory structure (e.g., all versions of `root_prompt` in the same folder), making version detection straightforward through directory scanning. The system doesn't support distributed version storage (versions in different locations).
- Latest version determination uses semantic versioning comparison rules: versions are compared component-wise (major.minor.patch) numerically, with simplified forms normalized to full semantic versions during comparison. This ensures v1.1.1 is newer than v1.1.0, which is newer than v1.0.0.
- Export operations preserve the hierarchical directory structure from source, maintaining nested subdirectories and relative path relationships. Path references in prompt files are resolved to work correctly within the preserved structure. The export doesn't create archive files (zip, tar) but produces directory structures that can be archived externally if needed.
- Cleanup validation uses heuristics to distinguish export directories from source directories. Export directories typically have version postfixes in names, contain preserved hierarchical structures matching source layouts, or have metadata indicating they were created by export. If validation is uncertain, explicit confirmation is required.
- Versioning applies at the file loading stage before rendering. Inline mode loads source files at specific versions, then inlines them (losing version information in output). File-first mode loads source files at specific versions and preserves file references in output.
- The system caches version listings per directory to improve performance when loading multiple prompts from the same directory. Cache invalidation occurs when directory modification time changes, ensuring cache consistency.
- Hierarchical version specifications allow fine-grained control but default to "latest" for unspecified paths, providing sensible defaults while enabling explicit version control when needed.
- Detailed structured logging is provided with configurable levels (DEBUG/INFO/WARNING/ERROR) via environment variable. Default logging level is INFO, providing essential operation logs without excessive verbosity. DEBUG level enables comprehensive diagnostics including all version resolution steps, file discovery operations, version comparisons, and cache operations. Logging is structured with fields (version, path, operation, timestamp) for programmatic filtering and analysis.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Designers can load prompts from directories with versioned files, and the system correctly resolves to the latest version in 100% of test cases when `version="latest"` is specified (or omitted).
- **SC-002**: Designers can load prompts with specific version specifications (e.g., `version="v2"`), and the system correctly resolves to the specified version file in 100% of test cases.
- **SC-003**: When a requested version doesn't exist, the system provides helpful error messages listing available versions in 100% of cases, enabling designers to quickly identify correct version identifiers.
- **SC-004**: Designers can export prompt hierarchies at specific versions, and exported structures contain all referenced files at their resolved versions, verified by integration tests covering hierarchies with at least 3 levels of nesting.
- **SC-005**: Export operations complete successfully for hierarchies with up to 50 referenced files in under 5 seconds, demonstrating acceptable performance for typical use cases.
- **SC-006**: Cleanup operations successfully remove exported directories in 100% of test cases, with zero false positives (source directories incorrectly identified as export directories) and zero false negatives (export directories incorrectly protected).
- **SC-007**: Version resolution works correctly with both inline and file-first render modes, verified by integration tests using both modes with the same versioned prompt hierarchies.
- **SC-008**: All related pytest suites (unit, integration, contract) pass locally and in CI with evidence linked in the PR. Test coverage for versioning functionality is >80% for core use cases.
- **SC-009**: Relevant docs_site pages are updated with versioning guide covering all user stories, and all new entities and use cases have comprehensive docstrings.
- **SC-010**: Designers can use hierarchical version specifications to load different parts of a prompt hierarchy at different versions, and the system correctly applies version rules at each level, verified by integration tests with at least 2 levels of nesting.
